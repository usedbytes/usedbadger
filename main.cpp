#include "pico/stdlib.h"
#include <stdio.h>
#include <cstring>
#include <string>
#include <algorithm>
#include "pico/time.h"
#include "pico/platform.h"
#include "pico/multicore.h"

#include "common/pimoroni_common.hpp"
#include "badger2040.hpp"

#include "fatfs/ff.h"
#include "fat_ramdisk.h"
#include "usb.h"
#include "usb_msc.h"

using namespace pimoroni;

enum
{
  ERROR_DISK_BLOCK_NUM  = 16, // 8KB is the smallest size that windows allow to mount
  ERROR_DISK_BLOCK_SIZE = 512,
  ERROR_CONTENTS_BLOCK = 3,
  ERROR_SIZE_BLOCK = 2,
  ERROR_SIZE_OFFSET = 32 + 28,
};

const uint8_t error_disk[ERROR_DISK_BLOCK_NUM][ERROR_DISK_BLOCK_SIZE] =
{
  //------------- Block0: Boot Sector -------------//
  // byte_per_sector    = ERROR_DISK_BLOCK_SIZE; fat12_sector_num_16  = ERROR_DISK_BLOCK_NUM;
  // sector_per_cluster = 1; reserved_sectors = 1;
  // fat_num            = 1; fat12_root_entry_num = 16;
  // sector_per_fat     = 1; sector_per_track = 1; head_num = 1; hidden_sectors = 0;
  // drive_number       = 0x80; media_type = 0xf8; extended_boot_signature = 0x29;
  // filesystem_type    = "FAT12   "; volume_serial_number = 0x1234; volume_label = "ERROR";
  // FAT magic code at offset 510-511
  {
      0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30, 0x00, 0x02, 0x01, 0x01, 0x00,
      0x01, 0x10, 0x00, 0x10, 0x00, 0xF8, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x29, 0x34, 0x12, 0x00, 0x00, 'E' , 'R' , 'R' , 'O' , 'R' ,
      ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , 0x46, 0x41, 0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00,

      // Zero up to 2 last bytes of FAT magic code
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
  },

  //------------- Block1: FAT12 Table -------------//
  {
      0xF8, 0xFF, 0xFF, 0xFF, 0x0F // // first 2 entries must be F8FF, third entry is cluster end of readme file
  },

  //------------- Block2: Root Directory -------------//
  {
      // first entry is volume label
      'E' , 'R' , 'R' , 'O' , 'R' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , 0x08, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x6D, 0x65, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // second entry is error file
      'E' , 'R' , 'R' , 'O' , 'R' , ' ' , ' ' , ' ' , 'T' , 'X' , 'T' , 0x20, 0x00, 0xC6, 0x52, 0x6D,
      0x65, 0x43, 0x65, 0x43, 0x00, 0x00, 0x88, 0x6D, 0x65, 0x43, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00
  },

  //------------- Block3: File Content -------------//
};

static void init_fat(struct msc_ctx *ctx)
{
	char error_buf[32];
	const unsigned int block_size = 512;
	const unsigned int num_blocks = 128;
	// Minimum size for FatFS
	uint8_t *disk_data = static_cast<uint8_t *>(calloc(1, num_blocks * block_size));
	static struct fat_ramdisk fat_disk = {
		.block_size = block_size,
		.num_blocks = num_blocks,
		.data = disk_data,
	};

	fat_ramdisk_init(&fat_disk, 1);

	MKFS_PARM opt = {
		.fmt = FM_FAT | FM_SFD,
		.n_fat = 0,
		.align = 0,
		.n_root = 0,
		.au_size = 0,
	};

	FATFS fs = { 0 };
	FIL fp = { 0 };
	UINT bw;
	const char *contents = "This is the readme written via fatfs";

	FRESULT res = f_mkfs("", &opt, NULL, 512);
	if (res) {
		snprintf(error_buf, sizeof(error_buf), "f_mkfs: %d", res);
		goto err_out;
	}

	res = f_mount(&fs, "", 1);
	if (res) {
		snprintf(error_buf, sizeof(error_buf), "f_mount: %d", res);
		goto err_out;
	}

	res = f_setlabel("usedbadger");
	if (res) {
		snprintf(error_buf, sizeof(error_buf), "f_setlabel: %d", res);
		goto err_unmount;
	}

	res = f_open(&fp, "readme.txt", FA_WRITE | FA_CREATE_ALWAYS);
	if (res) {
		snprintf(error_buf, sizeof(error_buf), "f_open: %d", res);
		goto err_unmount;
	}

	res = f_write(&fp, contents, strlen(contents), &bw);
	if (res) {
		snprintf(error_buf, sizeof(error_buf), "f_write: %d", res);
		goto err_close;
	}

	res = f_close(&fp);
	if (res) {
		snprintf(error_buf, sizeof(error_buf), "f_close: %d", res);
		goto err_unmount;
	}

	f_unmount("");

	ctx->block_size = block_size;
	ctx->num_blocks = num_blocks;
	ctx->data = disk_data;
	ctx->read_only = false;

	return;

err_close:
	f_close(&fp);
err_unmount:
	f_unmount("");
err_out:

	// Set-up the default hard-coded FS if something went wrong
	memcpy(disk_data, &error_disk[0][0], sizeof(error_disk));

	char *dst_contents = reinterpret_cast<char *>(&disk_data[ERROR_CONTENTS_BLOCK * ERROR_DISK_BLOCK_SIZE]);
	snprintf(dst_contents, ERROR_DISK_BLOCK_SIZE,
			"Encountered error setting up filesystem: %s\n", error_buf);

	uint32_t file_size = strnlen(dst_contents, ERROR_DISK_BLOCK_SIZE);
	char *dst_size = reinterpret_cast<char *>(&disk_data[ERROR_SIZE_BLOCK * ERROR_DISK_BLOCK_SIZE + ERROR_SIZE_OFFSET]);
	memcpy(dst_size, &file_size, sizeof(file_size));

	ctx->block_size = ERROR_DISK_BLOCK_SIZE;
	ctx->num_blocks = ERROR_DISK_BLOCK_NUM;
	ctx->read_only = true;
	ctx->data = disk_data;

	return;
}

void core1_main()
{
	static struct msc_ctx msc_ctx = {
		.vid = "TinyUSB",
		.pid = "Mass Storage",
		.rev = "1.0",
	};

	init_fat(&msc_ctx);
	usb_msc_init(&msc_ctx);

	usb_main();

	// Will never reach here
	return;
}

// this simple example tells you which button was used to wake up
// Badger2040 and then immediately halts again on another button press

Badger2040 badger;

int main() {

	badger.init();

	// find which button was used to wake up
	std::string button = "";
	std::string message = "started up.";
	if(badger.pressed_to_wake(badger.A)) { button += "A"; }
	if(badger.pressed_to_wake(badger.B)) { button += "B"; }
	if(badger.pressed_to_wake(badger.C)) { button += "C"; }
	if(badger.pressed_to_wake(badger.D)) { button += "D"; }
	if(badger.pressed_to_wake(badger.E)) { button += "E"; }

	if(button != "") {
		message = "woken up by button " + button + ".";
	}

	if (gpio_get(badger.VBUS_DETECT)) {
		message = "on VBUS";
		multicore_launch_core1(core1_main);
	}

	badger.thickness(2);

	badger.pen(15);
	badger.clear();
	badger.pen(0);
	badger.text(message, 10, 20, 0.6f);
	badger.text("(press any button to go to sleep.)", 10, 70, 0.4f);
	badger.update();

	while (badger.is_busy()) {
		sleep_ms(10);
	}

	badger.wait_for_press();

	/*
	badger.pen(15);
	badger.clear();
	badger.pen(0);
	badger.text("going back to sleep...", 10, 20, 0.6f);
	badger.text("z", 220, 50, 0.6f);
	badger.text("z", 230, 40, 0.8f);
	badger.text("z", 240, 30, 1.0f);
	badger.text("(press any button to wake up.)", 10, 70, 0.4f);
	badger.update();

	while (badger.is_busy()) {
		sleep_ms(10);
	}
	*/

	if (!gpio_get(badger.VBUS_DETECT)) {
		badger.halt();
	} else {
		//do_fat();
		uint8_t val = 0xff;
		while (1) {
			printf("Hello?\n");
			sleep_ms(500);
			val = ~val;
			badger.led(val);
		}
	}

}
